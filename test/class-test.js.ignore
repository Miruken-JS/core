import { Base } from "../src/base2";
import { Enum, Flags } from "../src/enum";
import { Protocol, conformsTo, $protocols } from "../src/protocol";
import { Policy } from "../src/policy";

import { design, designWithReturn } from "../src/design";
import { inject } from "../src/inject";

import "reflect-metadata";
import "../src/promise";

import { expect } from "chai";

const Code  = Symbol(),
      Breed = Symbol();

const Animal = Protocol.extend({
    name:   "",
    [Code]: undefined,

    talk() {},
    eat(food) {},
    [Breed]() {}
});

class Person {
    firstName = "";
    lastName  = "";
    dob;
    pet;
    
    get fullName() {
        return this.firstName + " " + this.lastName;
    }
    set fullname(value) {
        const parts = value.split(" ");
        if (parts.length > 0) {
            this.firstName = parts[0];
        }
        if (parts.length > 1) {
            this.lastName = parts[1];
        }
    }
    
    get age() { return ~~((Date.now() - +this.dob) / (31557600000)); }
};

const Tricks = Protocol.extend({
    fetch (item) {}
});

const CircusAnimal = Animal.extend(Tricks, {
});

@conformsTo(Animal, Tricks)
class Dog {
    constructor(name, color) {
        this.name  = name;
        this.color = color;
    }
    
    get name() { return name; }
    set name(value) { name = value; }
    
    get color() { return color; }
    set color(value) { color = value; }
    
    talk() { return "Ruff Ruff"; }
    
    fetch(item) { return "Fetched " + item; }
    
    get [Code]() { return 1234; }    
};
    
const Elephant = Base.extend(CircusAnimal, {
});

const Tracked = Protocol.extend({
	getTag() {}
});

const AsianElephant = Elephant.extend(Tracked);

describe("$isClass", () => {
    it("should identify miruken classes", () => {
        expect($isClass(Dog)).to.be.true;
    });
});

describe("Protocol", () => {
    it("should proxy calls to properties", () => {
        const dog = Animal(new Dog("Bowser"));
        expect(dog.name).to.equal("Bowser");
    });
    
    it("should proxy calls to methods", () => {
        const dog = Animal(new Dog());
        expect(dog.talk()).to.equal("Ruff Ruff");
    });
    
    it("should ignore null or undefined target", () => {
        Animal().talk();
        Animal(null).talk();
    });
    
    it("should ignore missing methods", () => {
        const dog = Animal(new Dog());
        dog.eat("bug");
    });
    
    it("should support specialization", () => {
        expect(CircusAnimal(new Dog()).fetch("bone")).to.equal("Fetched bone");
    });
     
    describe("#isProtocol", () => {
        it("should determine if type is a protocol", () => {
            expect(Protocol.isProtocol(Animal)).to.be.true;
            expect(Protocol.isProtocol(CircusAnimal)).to.be.true;
            expect(Protocol.isProtocol(Dog)).to.be.false;
            expect(Protocol.isProtocol(AsianElephant)).be.false;
        });

        it("should not consider Protocol a protocol", () => {
            expect(Protocol.isProtocol(Protocol)).to.be.false;
        });
    });

    describe("$protocols", () => {
        it("should retrieve own protocols", () => {
            expect($protocols(Dog, true)).to.have.members([Animal, Tricks]);
        });

        it("should retrieve all protocol protocols", () => {
            expect($protocols(CircusAnimal)).to.have.members([Animal, Tricks]);
        });

        it("should retrieve all class protocols", () => {
            expect($protocols(AsianElephant)).to.have.members([Tracked, CircusAnimal, Animal, Tricks]);
        });        
    });

    describe("#implement", () => {
        it("should extend protocol", () => {
            Animal.implement({
               reproduce() {}
            });
            const dog = new Dog();
            expect(Animal(dog).reproduce()).to.be.undefined;
            dog.extend({
                reproduce() {
                    return new Dog("Hazel");
                }
            });
            expect(Animal(dog).reproduce().name).to.equal("Hazel");
        });
    });

    describe("#extend", () => {
        it("should extend protocol instance", () => {
            const dog    = new Dog(),
                  animal = Animal(dog).extend({
                               reproduce() {}                
                           });
            expect(animal.reproduce()).to.be.undefined;
            dog.extend({
                reproduce() {
                    return new Dog("Hazel");
                }
            });
            expect(animal.reproduce().name).to.equal("Hazel");
        });
    });

    describe("#isAdoptedBy", () => {
        it("should determine if protocol adopted by class", () => {
            expect(Animal.isAdoptedBy(Dog)).to.be.true;
        });

        it("should determine if protocol adopted by protocol", () => {
            expect(Protocol.isAdoptedBy(Animal)).to.be.true;
            expect(Tricks.isAdoptedBy(Animal)).to.be.false;
            expect(Animal.isAdoptedBy(CircusAnimal)).to.be.true;
        });

        it("should determine if protocol adopted by object", () => {
            expect(Animal.isAdoptedBy(new Dog())).to.be.true;
        });

        it("should conform to protocols by class", () => {
			expect(Animal.isAdoptedBy(Dog)).to.be.true;
		    expect(Tricks.isAdoptedBy(Dog)).to.be.true;
        });

        it("should conform to protocols by protocol", () => {
            expect(Animal.isAdoptedBy(CircusAnimal)).to.be.true;
            expect(Tricks.isAdoptedBy(CircusAnimal)).to.be.true;
            expect(Tricks.isAdoptedBy(Animal)).to.be.false;
            expect(CircusAnimal.isAdoptedBy(CircusAnimal)).to.be.true;
        });

        it("should conform to protocols by object", () => {
            const dog = new Dog();
            expect(Animal.isAdoptedBy(dog)).to.be.true;
            expect(Animal.isAdoptedBy(dog)).to.be.true;
        });

        it("should only list protocol once", () => {
            const Cat = Base.extend(Animal, Animal);
            expect(Animal.isAdoptedBy(Cat)).to.be.true;
            expect($protocols(Cat, true)).to.eql([Animal]);
        });

        it("should only list protocol once if extended", () => {
            const Cat = Animal.extend(Animal);
            expect(Animal.isAdoptedBy(Cat)).to.be.true;
            expect($protocols(Cat, true)).to.eql([Animal]);
        });

        it("should support protocol inheritance", () => {
            expect(Animal.isAdoptedBy(Elephant)).to.be.true;
            expect($protocols(CircusAnimal, true)).to.have.members([Animal, Tricks]);
        });

        it("should inherit protocol conformance", () => {
            expect(Animal.isAdoptedBy(AsianElephant)).to.be.true;
            expect(Tricks.isAdoptedBy(AsianElephant)).to.be.true;
        });

        it("should accept array of protocols", () => {
            const EndangeredAnimal = Base.extend([Animal, Tracked]);
            expect(Animal.isAdoptedBy(EndangeredAnimal)).to.be.true;
            expect(Tracked.isAdoptedBy(EndangeredAnimal)).to.be.true;
            expect($protocols(EndangeredAnimal, true)).to.have.members([Animal, Tracked]);
        });

        it("should allow redefining method", () => {
            const SmartTricks = Tricks.extend({
                    fetch(item) {}
                }),
                SmartDog = Dog.extend({
                    fetch(item) { return "Buried " + item; }
                }),
                dog = new SmartDog();
            expect(SmartTricks(dog).fetch("bone")).to.equal("Buried bone");
        });
    });

    describe("#adoptProtocol", () => {
        it("should add protocol to class", () => {
            const Bird  = Base.extend(Animal),
                  eagle = (new Bird()).extend({
                   getTag() { return "Eagle"; }
				  });
            Tracked.adoptBy(Bird);
            expect(Tracked.isAdoptedBy(Bird)).to.be.true;
			expect(eagle.getTag()).to.equal("Eagle");
        });

        it("should add protocol to protocol", () => {
            const Bear      = Base.extend(Animal),
                  polarBear = (new Bear()).extend({
                  getTag() { return "Polar Bear"; }
            });
			Tracked.adoptBy(Animal);
            expect(Tracked.isAdoptedBy(polarBear)).to.be.true;
			expect(polarBear.getTag()).to.equal("Polar Bear");
			expect(Animal(polarBear).getTag()).to.equal("Polar Bear");
        });
    })

describe("@design", () => {
    const Zoo = Base.extend({
              @design(Person)
              trainer: undefined,
        
              @design(Person, [Animal])
              constructor(zooKeeper, animals) {},

              @design(Person)
              get doctor() { return this._doctor; },
              set doctor(value) { this._doctor = value; },
        
              @design(Dog, Elephant, AsianElephant)
              safari(dog, elephant, asianElephant) {},

              @designWithReturn(Animal, Dog, Elephant, AsianElephant)
              race(dog, elephant, asianElephant) {
                  return dog;
              }
          }),
          PettingZoo = Zoo.extend(design(Person, Person, [Animal]), {
              constructor(zooKeeper, trainer, animals) {
                  this.base(zooKeeper, animals);
              }
          });
    
    it("should get constructor design", () => {
        const types = design.get(Zoo.prototype, "constructor");
        expect(types[0]).to.equal(Person);
        expect(types[1]).to.eql([Animal]);        
    });

    it("should get method design", () => {
        const types = design.get(Zoo.prototype, "safari");
        expect(types).to.eql([Dog, Elephant, AsianElephant]);
    });

    it("should get method design with return", () => {
        const types = designWithReturn.get(Zoo.prototype, "race");
        expect(types).to.eql([Animal, Dog, Elephant, AsianElephant]);
    });
    
    it("should get field design", () => {
        const type = design.get(Zoo.prototype, "trainer");
        expect(type).to.equal(Person);
    });

    it("should get property design", () => {
        const type = design.get(Zoo.prototype, "doctor");
        expect(type).to.equal(Person);
    });
        
    it("should apply class design to constructor", () => {
        const types = design.get(PettingZoo.prototype, "constructor");
        expect(types[0]).to.equal(Person);
        expect(types[1]).to.equal(Person);        
        expect(types[2]).to.eql([Animal]);
    });

    it("should reject design if too few method types", () => {
        expect(() => {
            Base.extend({
                @design(Person)
                constructor(partner, canine) {}
            });
        }).to.throw(Error, "@design for method 'constructor' expects at least 2 parameters but only 1 specified");
    });
    
    it("should reject design if missing property type", () => {
        expect(() => {
            Base.extend({
                @design
                friend: undefined
            });
        }).to.throw(Error, "@design for property 'friend' requires a single type to be specified");
    });

    it("should reject property design on both getter and setter", () => {
        expect(() => {
            const Farm = Base.extend({
                @design(Person)
                get farmer() {},
                @design(Person)            
                set farmer(value) {}
            });
        }).to.throw(Error, "@design for property 'farmer' should only be specified on getter or setter");        
    });

    it("should reject invalid array specifications", () => {
        expect(() => {
            Base.extend({
                @design(Person, [Person, Person])
                sing(conductor, chorus) {} 
            });
        }).to.throw(Error, "@design array specification at index 1 expects a single type");
    });    
});

describe("inject", () => {
    const Circus = Base.extend({
              @inject($every(Animal))        
              constructor(animals) {},
        
              @inject(Dog)
              dancingDog(dance) {},
        
              @inject($every(Elephant))
              elpehantParade(elephant) {}
          }),
          RingBrothers = Circus.extend(inject(undefined, Person), {
              constructor(animals, ringMaster) {},
          });
    
    it("should get class dependencies", () => {
        const dep = inject.get(Circus.prototype, "dancingDog");
        expect(dep).to.eql([Dog]);
    });

    it("should get dependencies with modifiers", () => {
        const dep = inject.get(Circus.prototype, "elpehantParade");
        expect($every.test(dep[0])).to.be.true;
        expect(Modifier.unwrap(dep[0])).to.equal(Elephant);
    });

    it("should get constructor dependencies", () => {
        const dep = inject.get(Circus.prototype, "constructor");
        expect($every.test(dep[0])).to.be.true;
        expect(Modifier.unwrap(dep[0])).to.equal(Animal);
    });

    it("should apply class dependencies to constructor", () => {
        const dep = inject.get(RingBrothers.prototype, "constructor");
        expect(dep).to.eql([undefined, Person]);
    });

    it("should get own class dependencies", () => {
        const dep = inject.getOwn(RingBrothers.prototype, "dancingDog");
        expect(dep).to.be.undefined;
    });

    it("should get all dependencies", () => {
        const deps = new Map();
        inject.getKeys(RingBrothers.prototype, (d, k) => deps.set(k, d));
        expect(deps.get("dancingDog")).to.eql([Dog]);
        expect($every.test(deps.get("elpehantParade")[0])).to.be.true;
        expect(Modifier.unwrap(deps.get("elpehantParade")[0])).to.equal(Elephant);
        expect(deps.get("constructor")).to.eql([undefined, Person]);        
    });

    it("should get own dependencies", () => {
        const deps = new Map();
        inject.getOwnKeys(RingBrothers.prototype, (d, k) => deps.set(k, d));
        expect(deps.get("dancingDog")).to.be.undefined;
        expect(deps.get("elpehantParade")).to.be.undefined;
        expect(deps.get("constructor")).to.eql([undefined, Person]);
        inject.getOwnKeys(Circus.prototype, (d, k) => deps.set(k,d));
        expect(deps.get("dancingDog")).to.eql([Dog]);
    });            
});

